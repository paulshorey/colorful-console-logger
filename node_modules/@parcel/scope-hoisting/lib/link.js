"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.link = link;

function _nullthrows() {
  const data = _interopRequireDefault(require("nullthrows"));

  _nullthrows = function () {
    return data;
  };

  return data;
}

function _assert() {
  const data = _interopRequireDefault(require("assert"));

  _assert = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = require("path");

  _path = function () {
    return data;
  };

  return data;
}

function _template() {
  const data = _interopRequireDefault(require("@babel/template"));

  _template = function () {
    return data;
  };

  return data;
}

function t() {
  const data = _interopRequireWildcard(require("@babel/types"));

  t = function () {
    return data;
  };

  return data;
}

function _babelAstUtils() {
  const data = require("@parcel/babel-ast-utils");

  _babelAstUtils = function () {
    return data;
  };

  return data;
}

function _traverse() {
  const data = _interopRequireDefault(require("@babel/traverse"));

  _traverse = function () {
    return data;
  };

  return data;
}

function _shake() {
  const data = _interopRequireDefault(require("./shake"));

  _shake = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("./utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _index() {
  const data = _interopRequireDefault(require("./formats/index.js"));

  _index = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const ESMODULE_TEMPLATE = _template().default.statement(`$parcel$defineInteropFlag(EXPORTS);`);

const DEFAULT_INTEROP_TEMPLATE = _template().default.statement('var NAME = $parcel$interopDefault(MODULE);');

const THROW_TEMPLATE = _template().default.statement('$parcel$missingModule(MODULE);');

const REQUIRE_RESOLVE_CALL_TEMPLATE = _template().default.expression('require.resolve(ID)');

const FAKE_INIT_TEMPLATE = _template().default.statement(`function INIT(){
  return EXPORTS;
}`);

function link({
  bundle,
  bundleGraph,
  ast,
  options,
  wrappedAssets
}) {
  let format = _index().default[bundle.env.outputFormat];

  let replacements = new Map();
  let imports = new Map();
  let assets = new Map();
  let exportsMap = new Map();
  let importedFiles = new Map();
  let referencedAssets = new Set(); // return {ast, referencedAssets};
  // If building a library, the target is actually another bundler rather
  // than the final output that could be loaded in a browser. So, loader
  // runtimes are excluded, and instead we add imports into the entry bundle
  // of each bundle group pointing at the sibling bundles. These can be
  // picked up by another bundler later at which point runtimes will be added.

  if (bundle.env.isLibrary) {
    let bundles = bundleGraph.getSiblingBundles(bundle);

    for (let b of bundles) {
      importedFiles.set((0, _nullthrows().default)(b.filePath), {
        bundle: b,
        assets: new Set()
      });
    }
  } // Build a mapping of all imported identifiers to replace.


  bundle.traverseAssets(asset => {
    assets.set((0, _utils().assertString)(asset.meta.id), asset);
    exportsMap.set((0, _utils().assertString)(asset.meta.exportsIdentifier), asset);

    for (let dep of bundleGraph.getDependencies(asset)) {
      let resolved = bundleGraph.getDependencyResolution(dep, bundle);
      let skipped = bundleGraph.isDependencySkipped(dep); // If the dependency was skipped, the `...$import$..` identifier needs to be removed.
      // If the dependency was excluded, it will be replaced by the output format at the very end.

      if (resolved || skipped) {
        for (let [imported, {
          local,
          loc
        }] of dep.symbols) {
          imports.set(local, resolved && !skipped ? [resolved, imported, loc] : null);
        }
      }
    }

    if (bundleGraph.isAssetReferencedByDependant(bundle, asset)) {
      referencedAssets.add(asset);
    }
  });

  function resolveSymbol(inputAsset, inputSymbol, bundle) {
    let {
      asset,
      exportSymbol,
      symbol,
      loc
    } = bundleGraph.resolveSymbol(inputAsset, inputSymbol, bundle);

    if (asset.meta.resolveExportsBailedOut) {
      return {
        asset: asset,
        symbol: exportSymbol,
        identifier: null,
        loc
      };
    }

    let identifier = symbol;

    if (identifier && imports.get(identifier) === null) {
      // a deferred import
      return {
        asset: asset,
        symbol: exportSymbol,
        identifier: null,
        loc
      };
    } // If this is a wildcard import, resolve to the exports object.


    if (asset && exportSymbol === '*') {
      identifier = (0, _utils().assertString)(asset.meta.exportsIdentifier);
    }

    if (replacements && identifier && replacements.has(identifier)) {
      identifier = replacements.get(identifier);
    }

    return {
      asset: asset,
      symbol: exportSymbol,
      identifier,
      loc
    };
  }

  function maybeReplaceIdentifier(path) {
    let {
      name
    } = path.node;

    if (typeof name !== 'string') {
      return;
    }

    let replacement = replacements.get(name);

    if (replacement) {
      path.node.name = replacement;
    }

    if (imports.has(name)) {
      let node;
      let imported = imports.get(name);

      if (imported == null) {
        // import was deferred
        node = t().objectExpression([]);
      } else {
        let [asset, symbol] = imported;
        node = replaceImportNode(asset, symbol, path); // If the export does not exist, replace with an empty object.

        if (!node) {
          node = t().objectExpression([]);
        }
      }

      path.replaceWith(node);

      if ((0, t().isObjectExpression)(node)) {
        (0, _assert().default)(node.properties.length === 0);
      } else if ((0, t().isIdentifier)(node)) {
        (0, _nullthrows().default)(path.scope.getBinding(node.name)).reference(path);
      } else {
        if ((0, t().isCallExpression)(node)) {
          // $id$init()
          (0, _assert().default)((0, t().isIdentifier)(node.callee));
          (0, _nullthrows().default)(path.scope.getBinding(node.callee.name)).reference(path.get('callee'));
        } else {
          (0, _assert().default)((0, t().isMemberExpression)(node));

          if ((0, t().isIdentifier)(node.object)) {
            (0, _nullthrows().default)(path.scope.getBinding(node.object.name)).reference(path.get('object'));
          } else {
            // $id$init().prop
            (0, _assert().default)((0, t().isCallExpression)(node.object));
            let {
              callee
            } = node.object;
            (0, _assert().default)((0, t().isIdentifier)(callee));
            (0, _nullthrows().default)(path.scope.getBinding(callee.name)).reference(path.get('object.callee'));
          }
        }
      }
    } else if (exportsMap.has(name) && !path.scope.hasBinding(name)) {
      // If it's an undefined $id$exports identifier.
      (0, _utils().dereferenceIdentifier)(path.node, path.scope);
      path.replaceWith(t().objectExpression([]));
    }
  } // path is an Identifier like $id$import$foo that directly imports originalName from originalModule


  function replaceImportNode(originalModule, originalName, path) {
    let {
      asset: mod,
      symbol,
      identifier
    } = resolveSymbol(originalModule, originalName, bundle);
    let node = identifier ? findSymbol(path, identifier) : identifier; // If the module is not in this bundle, create a `require` call for it.

    if (!node && (!mod.meta.id || !assets.has((0, _utils().assertString)(mod.meta.id)))) {
      if (node === false) {
        // Asset was skipped
        return null;
      }

      node = addBundleImport(mod, path);
      return node ? interop(mod, symbol, path, node) : null;
    } // The ESM 'does not export' case was already handled by core's symbol proapgation.
    // Look for an exports object if we bailed out.
    // TODO remove the first part of the condition once bundleGraph.resolveSymbol().identifier === null covers this


    if (node === undefined && mod.meta.isCommonJS || node === null) {
      if (wrappedAssets.has(mod.id)) {
        node = t().callExpression((0, _utils().getIdentifier)(mod, 'init'), []);
      } else {
        node = findSymbol(path, (0, _utils().assertString)(mod.meta.exportsIdentifier));

        if (!node) {
          return null;
        }
      }

      node = interop(mod, symbol, path, node);
      return node;
    }

    return node;
  }

  function findSymbol(path, symbol) {
    if (symbol && replacements.has(symbol)) {
      symbol = replacements.get(symbol);
    } // if the symbol is in the scope there is no need to remap it


    if (symbol && path.scope.getProgramParent().hasBinding(symbol)) {
      return t().identifier(symbol);
    }

    return null;
  }

  function interop(mod, originalName, path, node) {
    // Handle interop for default imports of CommonJS modules.
    if (mod.meta.isCommonJS && originalName === 'default') {
      let name = (0, _utils().getName)(mod, '$interop$default');

      if (!path.scope.getBinding(name)) {
        let binding = (0, _nullthrows().default)(path.scope.getBinding(bundle.hasAsset(mod) && !wrappedAssets.has(mod.id) ? (0, _utils().assertString)(mod.meta.exportsIdentifier) : // If this bundle doesn't have the asset, use the binding for
        // the `parcelRequire`d init function.
        (0, _utils().getName)(mod, 'init')));
        (0, _assert().default)(binding.path.getStatementParent().parentPath.isProgram(), "Expected binding declaration's parent to be the program"); // Hoist to the nearest path with the same scope as the exports is declared in.

        let parent = (0, _nullthrows().default)(path.findParent(p => t().isProgram(p.parent)));
        let [decl] = parent.insertBefore(DEFAULT_INTEROP_TEMPLATE({
          NAME: t().identifier(name),
          MODULE: node
        }));
        binding.reference(decl.get('declarations.0.init'));
        getScopeBefore(parent).registerDeclaration(decl);
      }

      return t().identifier(name);
    } // if there is a CommonJS export return $id$exports.name


    if (originalName !== '*') {
      return t().memberExpression(node, t().identifier(originalName));
    }

    return node;
  }

  function getScopeBefore(path) {
    return path.isScope() ? path.parentPath.scope : path.scope;
  }

  function addExternalModule(path, dep) {
    // Find an existing import for this specifier, or create a new one.
    let importedFile = importedFiles.get(dep.moduleSpecifier);

    if (!importedFile) {
      importedFile = {
        source: dep.moduleSpecifier,
        specifiers: new Map(),
        isCommonJS: !!dep.meta.isCommonJS,
        loc: (0, _babelAstUtils().convertBabelLoc)(path.node.loc)
      };
      importedFiles.set(dep.moduleSpecifier, importedFile);
    }

    let programScope = path.scope.getProgramParent();
    (0, _assert().default)(importedFile.specifiers != null);
    let specifiers = importedFile.specifiers; // For each of the imported symbols, add to the list of imported specifiers.

    for (let [imported, {
      local
    }] of dep.symbols) {
      // If already imported, just add the already renamed variable to the mapping.
      let renamed = specifiers.get(imported);

      if (renamed) {
        replacements.set(local, renamed);
        continue;
      }

      renamed = replacements.get(local);

      if (!renamed) {
        // Rename the specifier to something nicer. Try to use the imported
        // name, except for default and namespace imports, and if the name is
        // already in scope.
        renamed = imported;

        if (imported === 'default' || imported === '*') {
          renamed = programScope.generateUid(dep.moduleSpecifier);
        } else if (programScope.hasBinding(imported) || programScope.hasReference(imported)) {
          renamed = programScope.generateUid(imported);
        }

        programScope.references[renamed] = true;
        replacements.set(local, renamed);
      }

      specifiers.set(imported, renamed);

      if (!programScope.hasOwnBinding(renamed)) {
        // add binding so we can track the scope
        let [decl] = programScope.path.unshiftContainer('body', t().variableDeclaration('var', [t().variableDeclarator(t().identifier(renamed))]));
        programScope.registerDeclaration(decl);
      }
    }

    return specifiers.get('*');
  }

  function addBundleImport(mod, path) {
    // Find a bundle that's reachable from the current bundle (sibling or ancestor)
    // containing this asset, and create an import for it if needed.
    let importedBundle = bundleGraph.findReachableBundleWithAsset(bundle, mod);

    if (!importedBundle) {
      throw new Error(`No reachable bundle found containing ${(0, _path().relative)(options.inputFS.cwd(), mod.filePath)}`);
    }

    let filePath = (0, _nullthrows().default)(importedBundle.filePath);
    let imported = importedFiles.get(filePath);

    if (!imported) {
      imported = {
        bundle: importedBundle,
        assets: new Set(),
        loc: (0, _babelAstUtils().convertBabelLoc)(path.node.loc)
      };
      importedFiles.set(filePath, imported);
    } // If not unused, add the asset to the list of specifiers to import.


    if (!isUnusedValue(path) && mod.meta.exportsIdentifier) {
      (0, _assert().default)(imported.assets != null);
      imported.assets.add(mod);
      let initIdentifier = (0, _utils().getIdentifier)(mod, 'init');
      let program = path.scope.getProgramParent().path;

      if (!program.scope.hasOwnBinding(initIdentifier.name)) {
        // add binding so we can track the scope
        // If parcelRequire exists in scope, be sure to insert after that so the global outputFormat
        // can add the rhs later and reference it properly.
        let declNode = t().variableDeclaration('var', [t().variableDeclarator(initIdentifier)]);
        let parcelRequire = program.scope.getBinding('parcelRequire');
        let decl;

        if (parcelRequire) {
          [decl] = parcelRequire.path.getStatementParent().insertAfter(declNode);
        } else {
          [decl] = program.unshiftContainer('body', [declNode]);
        }

        program.scope.registerDeclaration(decl);
      }

      return t().callExpression(initIdentifier, []);
    }
  }

  (0, _traverse().default)(ast, {
    CallExpression(path) {
      let {
        arguments: args,
        callee
      } = path.node;

      if (!(0, t().isIdentifier)(callee)) {
        return;
      } // each require('module') call gets replaced with $parcel$require(id, 'module')


      if (callee.name === '$parcel$require') {
        let [id, source] = args;

        if (args.length !== 2 || !(0, t().isStringLiteral)(id) || !(0, t().isStringLiteral)(source)) {
          throw new Error('invariant: invalid signature, expected : $parcel$require(number, string)');
        }

        let asset = (0, _nullthrows().default)(assets.get(id.value));
        let dep = (0, _nullthrows().default)(bundleGraph.getDependencies(asset).find(dep => dep.moduleSpecifier === source.value));
        let mod = bundleGraph.getDependencyResolution(dep, bundle);
        let node;

        if (!bundleGraph.isDependencySkipped(dep)) {
          if (!mod) {
            if (dep.isOptional) {
              node = THROW_TEMPLATE({
                MODULE: t().stringLiteral(source.value)
              });
            } else {
              let name = addExternalModule(path, dep);

              if (!isUnusedValue(path) && name) {
                node = t().identifier(name);
              }
            }
          } else {
            if (mod.meta.id && assets.has((0, _utils().assertString)(mod.meta.id))) {
              let name = (0, _utils().assertString)(mod.meta.exportsIdentifier);
              let isValueUsed = !isUnusedValue(path);

              if (asset.meta.isCommonJS && isValueUsed) {
                maybeAddEsModuleFlag(path.scope, mod);
              } // We need to wrap the module in a function when a require
              // call happens inside a non top-level scope, e.g. in a
              // function, if statement, or conditional expression.


              if (wrappedAssets.has(mod.id)) {
                node = t().callExpression((0, _utils().getIdentifier)(mod, 'init'), []);
              } // Replace with nothing if the require call's result is not used.
              else if (isValueUsed) {
                  node = t().identifier(replacements.get(name) || name);
                }
            } else if (mod.type === 'js') {
              node = addBundleImport(mod, path);
            }
          }
        }

        if (node) {
          path.replaceWith(node);
        } else {
          if (path.parentPath.isExpressionStatement()) {
            path.parentPath.remove();
          } else {
            // e.g. $parcel$exportWildcard;
            path.replaceWith(t().objectExpression([]));
          }
        }
      } else if (callee.name === '$parcel$require$resolve') {
        let [id, source] = args;

        if (args.length !== 2 || !(0, t().isStringLiteral)(id) || !(0, t().isStringLiteral)(source)) {
          throw new Error('invariant: invalid signature, expected : $parcel$require$resolve(number, string)');
        }

        let mapped = (0, _nullthrows().default)(assets.get(id.value));
        let dep = (0, _nullthrows().default)(bundleGraph.getDependencies(mapped).find(dep => dep.moduleSpecifier === source.value));

        if (!bundleGraph.getDependencyResolution(dep, bundle)) {
          // was excluded from bundling (e.g. includeNodeModules = false)
          if (bundle.env.outputFormat !== 'commonjs') {
            throw (0, _utils().getThrowableDiagnosticForNode)("`require.resolve` calls for excluded assets are only supported with outputFormat: 'commonjs'", mapped.filePath, (0, _babelAstUtils().convertBabelLoc)(path.node.loc));
          }

          path.replaceWith(REQUIRE_RESOLVE_CALL_TEMPLATE({
            ID: t().stringLiteral(source.value)
          }));
        } else {
          throw (0, _utils().getThrowableDiagnosticForNode)("`require.resolve` calls for bundled modules or bundled assets aren't supported with scope hoisting", mapped.filePath, (0, _babelAstUtils().convertBabelLoc)(path.node.loc));
        }
      } else if (callee.name === '$parcel$export') {
        let [obj, symbol] = args;
        (0, _assert().default)((0, t().isIdentifier)(obj));
        (0, _assert().default)((0, t().isStringLiteral)(symbol));
        let objName = obj.name;
        let symbolName = symbol.value;

        if (objName === 'exports') {
          // Assignment inside a wrapped asset
          return;
        }

        let asset = (0, _nullthrows().default)(exportsMap.get(objName));
        let incomingDeps = bundleGraph.getIncomingDependencies(asset);
        let unused = incomingDeps.every(d => {
          let symbols = bundleGraph.getUsedSymbols(d);
          return !symbols.has(symbolName) && !symbols.has('*');
        });

        if (unused) {
          (0, _utils().pathRemove)(path);
        }
      }
    },

    VariableDeclarator: {
      exit(path) {
        // Replace references to declarations like `var x = require('x')`
        // with the final export identifier instead.
        // This allows us to potentially replace accesses to e.g. `x.foo` with
        // a variable like `$id$export$foo` later, avoiding the exports object altogether.
        let {
          id,
          init
        } = path.node;

        if (!(0, t().isIdentifier)(init)) {
          return;
        }

        let module = exportsMap.get(init.name);

        if (!module) {
          return;
        }

        let isGlobal = path.scope == path.scope.getProgramParent(); // Replace patterns like `var {x} = require('y')` with e.g. `$id$export$x`.

        if ((0, t().isObjectPattern)(id)) {
          for (let p of path.get('id.properties')) {
            let {
              computed,
              key,
              value
            } = p.node;

            if (computed || !(0, t().isIdentifier)(key) || !(0, t().isIdentifier)(value)) {
              continue;
            }

            let {
              identifier
            } = resolveSymbol(module, key.name);

            if (identifier) {
              replace(value.name, identifier, p);

              if (isGlobal) {
                replacements.set(value.name, identifier);
              }
            }
          }

          if (id.properties.length === 0) {
            path.remove();
          }
        } else if ((0, t().isIdentifier)(id)) {
          replace(id.name, init.name, path);

          if (isGlobal) {
            replacements.set(id.name, init.name);
          }
        }

        function replace(id, init, path) {
          let binding = (0, _nullthrows().default)(path.scope.getBinding(id));

          if (!binding.constant) {
            return;
          }

          for (let ref of binding.referencePaths) {
            ref.replaceWith(t().identifier(init));
          }

          path.remove();
        }
      }

    },
    MemberExpression: {
      exit(path) {
        let {
          object,
          property,
          computed
        } = path.node;

        if (!((0, t().isIdentifier)(object) && ((0, t().isIdentifier)(property) && !computed || (0, t().isStringLiteral)(property)))) {
          return;
        }

        let asset = exportsMap.get(object.name);

        if (!asset) {
          return;
        } // If it's a $id$exports.name expression.


        let name = (0, t().isIdentifier)(property) ? property.name : property.value;
        let {
          identifier
        } = resolveSymbol(asset, name, bundle);

        if (identifier == null || identifier === false || !path.scope.hasBinding(identifier)) {
          return;
        }

        let {
          parent,
          parentPath
        } = path; // If inside an expression, update the actual export binding as well
        // (This is needed so that `require()`d CJS namespace objects can be mutatated.)

        if ((0, t().isAssignmentExpression)(parent, {
          left: path.node
        })) {
          if ((0, t().isIdentifier)(parent.right)) {
            maybeReplaceIdentifier(parentPath.get('right')); // do not modify `$id$exports.foo = $id$export$foo` statements

            if ((0, t().isIdentifier)(parent.right, {
              name: identifier
            })) {
              return;
            } // If the right side was imported from a different bundle, there is no $id$export$foo binding in this bundle


            if (!path.scope.hasBinding(identifier)) {
              return;
            }
          } // turn `$id$exports.foo = ...` into `$id$exports.foo = $id$export$foo = ...`


          parentPath.get('right').replaceWith(t().assignmentExpression('=', t().identifier(identifier), parent.right));
        } else {
          path.replaceWith(t().identifier(identifier));
        }
      }

    },

    ReferencedIdentifier(path) {
      maybeReplaceIdentifier(path);
    },

    Program: {
      exit(path) {
        // Recrawl to get all bindings.
        path.scope.crawl();

        for (let file of importedFiles.values()) {
          if (file.bundle) {
            format.generateBundleImports(bundle, file, path, bundleGraph);
          } else {
            format.generateExternalImport(bundle, file, path);
          }
        }

        if (referencedAssets.size > 0) {
          // Insert fake init functions that will be imported in other bundles,
          // because `asset.meta.shouldWrap` isn't set in a packager if `asset` is
          // not in the current bundle.
          for (let asset of referencedAssets) {
            maybeAddEsModuleFlag(path.scope, asset);
          }

          let decls = path.pushContainer('body', [...referencedAssets].filter(a => !wrappedAssets.has(a.id)).map(a => {
            return FAKE_INIT_TEMPLATE({
              INIT: (0, _utils().getIdentifier)(a, 'init'),
              EXPORTS: t().identifier((0, _utils().assertString)(a.meta.exportsIdentifier))
            });
          }));

          for (let decl of decls) {
            var _path$scope$getBindin;

            path.scope.registerDeclaration(decl);
            let returnId = decl.get('body.body.0.argument'); // TODO Sometimes deferred/excluded assets are referenced, causing this function to
            // become `function $id$init() { return {}; }` (because of the ReferencedIdentifier visitor).
            // But a asset that isn't here should never be referenced in the first place.

            (_path$scope$getBindin = path.scope.getBinding(returnId.node.name)) === null || _path$scope$getBindin === void 0 ? void 0 : _path$scope$getBindin.reference(returnId);
          }
        }

        // Generate exports
        let exported = format.generateExports(bundleGraph, bundle, referencedAssets, path, replacements, options, maybeReplaceIdentifier);
        (0, _shake().default)(path.scope, exported, exportsMap);
      }

    }
  });
  return {
    ast,
    referencedAssets
  };
}

function maybeAddEsModuleFlag(scope, mod) {
  // Insert __esModule interop flag if the required module is an ES6 module with a default export.
  // This ensures that code generated by Babel and other tools works properly.
  if (mod.meta.isES6Module && mod.symbols.hasExportSymbol('default')) {
    let name = (0, _utils().assertString)(mod.meta.exportsIdentifier);
    let binding = scope.getBinding(name);

    if (binding && !binding.path.getData('hasESModuleFlag')) {
      let f = (0, _nullthrows().default)(scope.getProgramParent().getBinding('$parcel$defineInteropFlag'));
      let paths = [...binding.constantViolations];

      if (binding.path.node.init) {
        paths.push(binding.path);
      }

      for (let path of paths) {
        let [stmt] = path.getStatementParent().insertAfter(ESMODULE_TEMPLATE({
          EXPORTS: t().identifier(name)
        }));
        f.reference(stmt.get('expression.callee'));
        binding.reference(stmt.get('expression.arguments.0'));
      }

      binding.path.setData('hasESModuleFlag', true);
    }
  }
}

function isUnusedValue(path) {
  let {
    parent
  } = path;
  return (0, t().isExpressionStatement)(parent) || (0, t().isSequenceExpression)(parent) && (Array.isArray(path.container) && path.key !== path.container.length - 1 || isUnusedValue(path.parentPath));
}